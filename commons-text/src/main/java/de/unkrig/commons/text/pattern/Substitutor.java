package de.unkrig.commons.text.pattern;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import de.unkrig.commons.lang.protocol.Function;
import de.unkrig.commons.lang.protocol.Transformer;

/**
 * Replaces pattern matches in a stream of strings ("chunks"). Matches are allowed across chunks; thus, this
 * transformer is stateful.
 * <p>
 *   As the substitutor <em>consumes</em> chunks, it <em>produces</em> a sequence of strings, and the concatenation of
 *   the chunks read equals the concatenation of the produced strings, except that all matches of the
 *   <var>pattern</var> are substituted with the replacements generated by the <var>matchReplacer</var>.
 * </p>
 * <p>
 *   Iff the input to the transformer is {@code ""} (the empty string), then the "rest" of any pending matches is
 *   returned. This is sort of a "flush" operation.
 * </p>
 * <p>
 *   The substitutor attempts to keep as little characters as possible in memory, which make it possible to find
 *   matches in documents that are too large to load into memory.
 * </p>
 * <p>
 *   If you plan to use "look-behinds" (the most common of which is "^"), bear in mind that the look-behind memory is
 *   limited; by default to {@value #DEFAULT_LOOKBEHIND_LIMIT}.
 * </p>
 * <p>
 *   Also bear in mind that, specifically when using "greedy quantifiers", that it may happen quite easily that the
 *   entire input must be read into memory, only to find that there is no match. E.g. the pattern {@code "a.*b"}, as
 *   soon as it hits the letter "a", will load all the remaining text into memory, because there might still come
 *   (another) "b".
 * </p>
 */
public
class Substitutor implements Transformer<CharSequence, CharSequence> {

    public static final int DEFAULT_LOOKBEHIND_LIMIT = 10;

    // CONFIGURATION

    private final Pattern                                           pattern;
    private final Function<? super Matcher, ? extends CharSequence> matchReplacer;
    private final int                                               lookBehindLimit;

    /**
     * Contains a suffix of the input char sequence.
     */
    StringBuilder buffer = new StringBuilder();

    /**
     * Offset in {@link #buffer}
     */
    int start;

    /**
     * Number of substitutions executed so far.
     */
    private int substitutionCount;

    public
    Substitutor(Pattern pattern, final Function<? super Matcher, ? extends CharSequence> matchReplacer) {
        this(pattern, matchReplacer, Substitutor.DEFAULT_LOOKBEHIND_LIMIT);
    }

    public
    Substitutor(
        Pattern                                           pattern,
        Function<? super Matcher, ? extends CharSequence> matchReplacer,
        int                                               lookBehindLimit
    ) {
        this.pattern         = pattern;
        this.matchReplacer   = matchReplacer;
        this.lookBehindLimit = lookBehindLimit;
    }

    /**
     * Substitutes all matches in the <var>subject</var> and returns it. If there is a "partial match" at the
     * end of the subject, then only a prefix of the result is returned, and the suffix is processed as part of
     * following invocations.
     */
    @Override public CharSequence
    transform(CharSequence in) {

        if (in.length() == 0) return this.flush();

        this.buffer.append(in);

        StringBuilder result = new StringBuilder();
        Matcher m = this.pattern.matcher(this.buffer);
        m.useTransparentBounds(true);
        m.useAnchoringBounds(false);

        for (;;) {
            m.region(this.start, this.buffer.length());
            if (m.lookingAt()) {
                if (m.hitEnd()) {

                    // E.g. "A.*B" => "AxxxBxx"
                    break;
                }

                // E.g. "A" => "Axxx"
                CharSequence replacement = this.matchReplacer.call(m);

                if (replacement == null) {
                    result.append(this.buffer.charAt(this.start++));
                } else {
                    result.append(replacement);
                    if (m.end() == m.start()) {
                        result.append(this.buffer.charAt(this.start++));
                    } else {
                        this.start = m.end();
                    }
                }
            } else {
                if (m.hitEnd()) {

                    // E.g. "Axxxxxx" => "Axxx"
                    break;
                }

                // E.g. "A" => "Bxx"
                if (this.start == this.buffer.length()) break;
                result.append(this.buffer.charAt(this.start++));
            }
        }

        if (this.start > this.lookBehindLimit) {

            // Truncate the buffer to save memory.
            this.buffer.delete(0, this.start - this.lookBehindLimit);
            this.start = this.lookBehindLimit;
        }

        if (this.buffer.capacity() > 10 * this.buffer.length()) this.buffer.trimToSize();

        return result.toString();
    }

    /**
     * @return The number of substitutions executed so far, i.e. the number of invocations of the
     *         <var>matchReplacer</var> that returned a non-{@code null} value
     */
    public int
    substitutionCount() { return this.substitutionCount; }

    private CharSequence
    flush() {

        if (this.buffer.length() == 0) return "";

        Matcher m = this.pattern.matcher(this.buffer);
        if (!m.find(this.start)) {

            // No match in "the rest" - just return "the rest".
            String result = this.buffer.substring(this.start);
            this.buffer.setLength(0);
            this.start = 0;
            return result;
        }

        StringBuilder result = new StringBuilder();
        do {

            CharSequence replacement = this.matchReplacer.call(m);
            if (replacement != null) {
                result.append(this.buffer, this.start, m.start()).append(replacement);
                this.start = m.end();
                this.substitutionCount++;
            }

            if (m.start() == m.end()) {

                // Special case: Zero-length match.
                if (this.start == this.buffer.length()) break;
                result.append(this.buffer.charAt(this.start++));
            }
        } while (m.find(this.start));

        result.append(this.buffer, this.start, this.buffer.length());
        this.buffer.setLength(0);
        this.start = 0;
        return result.toString();
    }
}